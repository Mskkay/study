#一、理解netty的意义
    学习一个技术，首先要知道这个技术是因为什么需求而出现的。通过它的需求和历史，能帮助我理解它
###1.1 netty是什么
    异步事件驱动框架
  需要注意的是，jdk本身是有异步接收消息的接口的（nio包）。netty与jdk的nio包的关系类似于spring与servlet
#####1.1.1 同步与异步
  同步与异步关注的是消息通讯机制  
  - 同步：发出一个消息请求，得到的返回消息必然是结果——当然可能会比较慢，因为被请求方得处理一下  
  - 异步：发出一个消息请求，立即得到返回值——然而这个返回值只是描述被请求方接收到了请求的标识，并不是结果，因此你需要轮询真正的结果or在传递消息时附带一个如何处理的句柄，当得到结果后由其他线程执行处理程序（比如ajax的写法和思路）
#####1.1.2 阻塞与非阻塞
  提到同步异步当然就要提一下阻塞与非阻塞。这俩描述的是程序在发出消息请求后的状态  
  - 阻塞：发出一个消息请求，一定要得到结果再往下走（当前线程会被挂起，调用线程只有在得到结果之后才会返回）  
  - 非阻塞：在没有获得返回结果之前，也可以干其他事情
  
  同步与异步，阻塞与非阻塞还有更多的思考，参考[标签1](4从netty思考更多.md)
  
#####1.1.3 事件驱动
    事件驱动基于基于发布-订阅模式的编程模型。是一种消息处理模型。
  举个栗子，如果有一个对外处理业务的地方（比如办身份证？），那么它应该怎么处理请求？  
  1. 开一个窗口。嗯，高峰期累死窗口，而且还让客户等得吐血。空闲期又没有得到利用，旱的旱死，涝的涝死
  2. 开n个窗口（多线程/进程）处理。大大提高了信息处理能力，同时大大增加了由于付不起n人工资而倒闭的风险（多线程会占用大量资源）。。。。
  3. 使用一个注册消息的地方（比如微信预约？），一旦有消息出现，它将被压入一个队列，然后处理者只需要从队列中不停取出消息进行处理

  第三个就是事件驱动。看起来它需要一个事件收集器，事件队列，以及将处理者（回调函数）注册给它。它更加合理地分配了系统资源来处理事件。通常适用于 
  1. 有许多任务需要处理
  2. 任务之间并没有什么联系，它们不需要通讯，也没有逻辑上的先后要求
  3. 有一些任务可以被延迟处理，并不要求绝对地快

#####1.1.4 bio,nio,aio
  1. bio指网络IO中，通过一个线程和一个连接一一对应的方式进行处理
  2. nio指通过IO多路复用来解决。更多请参考[bio,nio,aio](4从netty思考更多.md)
  3. aio也参考[bio,nio,aio](4从netty思考更多.md)
  
#二、netty是怎么构成的
###2.1 netty的组件
#####2.1.1 nioEventLoop
  netty的总的管理程序。实现netty的异步事件驱动
  
#####2.1.1 channel
  channel即是对socket的封装。  
  （存疑）为什么要这么封装呢？一个说法是：一方面用于IO多路复用的注册，另一方面网络socket的读写操作其实是由多个易阻塞的操作构成，交给netty管理这几步
 
#####2.1.2 pipeline
  用于注册处理事件的回调函数。使用责任链模式